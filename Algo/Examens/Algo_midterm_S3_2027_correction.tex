\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{extarrows}
\usepackage{soul}
\usepackage{listings}
\usepackage{minted}
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000
\let\oldemptyset\emptyset
\usepackage[T1]{fontenc}

\author{}
\date{}
\title{Midterm Algo 2027}

\begin{document}
\maketitle

\section{Questions de cours}
\begin{enumerate}
    \item Donnez une méthode de hachage direct: chainage séparé ou hachage coalescent
    \item Le problème qui apparait avec le hachage coalescent: des collisions secondaires peuvent apparaitre
    \item Une collision primaire est: une coïncidence de valeur entre h(x) et h(y) tel que x$\neq$y, avec h la fonction de hachage
    \item L'ordre d'un graphe non-orienté est: le nombre de sommet du graphe
    \item Un sommet isolé est: un sommet de degré num
    \item Le tableau des demi-degrés extérieurs des sommets de G:
    \begin{center}
    \begin{tabular}{ |c| c| c| c| c| c| c| c| c| }
        \hline
        1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
        \hline
        2 & 2 & 3 & 2 & 0 & 2 & 3 & 2 & 2 \\
        \hline
    \end{tabular}
    \end{center}
    \item Le graphe est-il fortement connexe: Non
    \item Si non, combien possède t-il de composantes fortement connexes? 2
    \item S'ils existent, les sommets de G de degré différent de 4 sont: 1,5 et 9
    \item S'ils existent, les sommets de G de demi-degré intérieur égal à 0 sont: $\varnothing$
\end{enumerate}

\newpage
\section{Arbres généraux}
\begin{lstlisting}[language=Python]
  def keys_after_bis(T,x):
    q = queue.Queue()
    q.enqueue(T)
    q_next = queue.Queue()
    found = False
    L = []
    while not q.isempty():
        while not q.isempty() and not found:
            T = q.dequeue()
            if T.key==x:
                found = True
            else:
                for C in T.children:
                    q_next.enqueue(C)
        if found:
            while not q.isempty():
                L.append(q.dequeue().key)
        else:
            (q,q_next) = (q_next,q)
    return L
\end{lstlisting}

\newpage
\begin{lstlisting}[language=Python]
def _test_subtrees(B):
    (nb,key_sum) = (1,B.key)
    C = B.child
    while C:
        (ok,n,s) = _test_subtrees(C)
        if not ok or s/n>B.key:
            return (False,nb,key_sum)
        nb+=n
        key_sum+=s
    return (True,nb,key_sum)

def average_subtrees(B):
    return _test_subtrees(B)[0]
\end{lstlisting}



\section{B-arbres}


\end{document}